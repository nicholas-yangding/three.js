<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<base href="../../../" />
		<script src="list.js"></script>
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
		[page:Texture] &rarr;

		<h1>[name]</h1>

		<p class="desc">直接从原始数据，宽度和高度创建纹理</p>


		<h2>构造器</h2>

		<h3>[name]( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy )</h3>
		<p>
			data参数必须是ArrayBuffer或类型化数组试图
			其它参数对应于从[page:Texture]集继承的属性, 其中magFilter和minFilter的默认值都是THREE.NearestFilter。flipY和generateMipmaps属性的初始值是false.
		</p>
		<p>
			对data的解释取决于type和format:
			如果type参数的值是THREE.UnsignedByteType, 那么Uint8Array 对于纹理元素数据的寻址非常有用.
			如果format参数值是THREE.RGBAFormat, data参数需为每个纹理元素提供4个值：红, 绿, 蓝和Alpha (表示透明度). 类似的, 如果format参数值是THREE.RGBFormat,则每个纹理元素只需要3个值<br />
			对于打包类型, THREE.UnsignedShort4444Type, THREE.UnsignedShort5551Type 或 THREE.UnsignedShort565Type, 1个纹理元素的所有颜色分量可以作为Uint16Array的整数元素内的位域来寻址<br />

            为了使用THREE.FloatType 和 THREE.HalfFloatType类型, WebGL的实现必须支持OES_texture_float和OES_texture_half_float扩展.
            为了将THREE.LinearFilter用于基于这些类型的纹理元素的分量以及双线性插值, 还必须有OES_texture_float_linear或OES_texture_half_float_linear扩展.
		</p>

		<h2>示例</h2>

		<code>
		// create a buffer with color data

		var size = width * height;
		var data = new Uint8Array( 3 * size );

		var r = Math.floor( color.r * 255 );
		var g = Math.floor( color.g * 255 );
		var b = Math.floor( color.b * 255 );

		for ( var i = 0; i < size; i ++ ) {

			var stride = i * 3;

			data[ stride ] = r;
			data[ stride + 1 ] = g;
			data[ stride + 2 ] = b;

		}

		// used the buffer to create a [name]

		var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
		texture.needsUpdate = true
		</code>

		<h2>属性</h2>

		<h3>[property:Image image]</h3>
		<p>
		重写了包含数据，宽度和高度的记录类型
		</p>

		<h2>方法</h2>


		<h2>源码</h2>

		[link:https://github.com/mrdoob/three.js/blob/master/src/[path].js src/[path].js]
	</body>
</html>
