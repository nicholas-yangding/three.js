<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<base href="../../../" />
		<script src="list.js"></script>
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
		<h1>[name]</h1>

		<p class="desc">创建要应用于曲面的纹理或作为反射或折射贴图</p>


		<h2>构造器</h2>

		<h3>[name]( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding )</h3>

		<h2>示例</h2>

		<code>
		// load a texture, set wrap mode to repeat
		var texture = new THREE.TextureLoader().load( "textures/water.jpg" );
		texture.wrapS = THREE.RepeatWrapping;
		texture.wrapT = THREE.RepeatWrapping;
		texture.repeat.set( 4, 4 );
		</code>

		<h2>属性</h2>

		<h3>[property:Integer id]</h3>
		<p>
		只读 - 该纹理实例的唯一标识符(数字型)
		</p>

		<h3>[property:String uuid]</h3>
		<p>
		该实例的[link:http://en.wikipedia.org/wiki/Universally_unique_identifier UUID]，自动分配，且不可被编辑。
		</p>

		<h3>[property:String name]</h3>
		<p>
		该对象的可选名称 (不必唯一)。 默认值是一个空串。
		</p>

		<h3>[property:Image image]</h3>
		<p>
		一个图片对象, 一般由[page:TextureLoader.load]方法创建。
		可以是任何three.js支持的图片(例如： PNG, JPG, GIF, DDS)或者视频 (例如： MP4, OGG/OGV)<br /><br />

		将视频用作纹理需要有一个播放视频的HTML5 video元素作为纹理的图片源并且随着视频的播放不断刷新纹理—— [page:VideoTexture VideoTexture]类自动处理了这一过程
		</p>

		<h3>[property:array mipmaps]</h3>
		<p>
		用户指定的mipmaps数组 (可选)
		</p>

		<h3>[property:number mapping]</h3>
		<p>
        图像是如何应用于对象的。默认是一个[page:Textures THREE.UVMapping]类型的对象,
		该对象中， U,V 坐标被应用于贴图 <br />

		其它mapping类型请参阅[page:Textures texture constants]
		</p>

		<h3>[property:number wrapS]</h3>
		<p>
		它定义了纹理是如何在水平方向上被包装并与UV坐标中的 *U* 对应的 <br />
		默认值是[page:Textures THREE.ClampToEdgeWrapping], 它的边缘被夹在外边缘的纹理元素中
		其它的两个选择分别是[page:Textures THREE.RepeatWrapping]和[page:Textures THREE.MirroredRepeatWrapping].
		详见[page:Textures texture constants]
		</p>

		<h3>[property:number wrapT]</h3>
		<p>
        它定义了纹理是如何在垂直方向上被包装并与UV坐标中的 *V* 对应的 <br />
		可选值与[property:number wrapS]一样<br /><br />

		说明: 只有当图片的尺寸(像素)是2的幂(2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, ...)时，纹理图片的平铺才能起效.
		每个维度上的尺寸不必相等，但必须是2的幂。这是WebGL的限制，不是three.js
		</p>

		<h3>[property:number magFilter]</h3>
		<p>
        当一个纹理元素覆盖多个像素时如何对纹理采样。默认值是[page:Textures THREE.LinearFilter]，它会获取
        4个最接近的纹理元素并在之间进行双线性插值。
        另一个可选值是[page:Textures THREE.NearestFilter], 它使用最近的那个纹理元素的值 <br />
		详见[page:Textures texture constants]
		</p>

		<h3>[property:number minFilter]</h3>
		<p>
        当一个纹理元素覆盖少于一个像素时如何对纹理采样。默认值[page:Textures THREE.LinearMipMapLinearFilter], 它使用mipmapping以及三线性过滤器 <br /><br />

		所有可能值请参阅[page:Textures texture constants]
		</p>

		<h3>[property:number anisotropy]</h3>
		<p>
		沿轴穿过具有最高纹理元素密度的像素的样本数
        默认值是1. 较高的值比基本的mipmap产生更少的模糊结果，以使用更多的纹理样本为代价。
        使用[page:WebGLRenderer.getMaxAnisotropy renderer.getMaxAnisotropy]() 找到GPU的最大有效各向异性值，这个值通常是2的幂
		</p>

		<h3>[property:number format]</h3>
		<p>
		默认值是[page:Textures THREE.RGBAFormat], 顺然[page:TextureLoader TextureLoader] 会自动将JPG格式图片的format值设为[page:Textures THREE.RGBFormat]<br /><br />

		其它格式值详见[page:Textures texture constants]
		</p>

		<h3>[property:number type]</h3>
		<p>
		它必须与[page:Texture.format .format]相对应。 默认值是 [page:Textures THREE.UnsignedByteType],它被应用于大部分的纹理格式。<br /><br />

		其它格式详见[page:Textures texture constants]
		</p>

		<h3>[property:Vector2 offset]</h3>
		<p>
		在UV坐标上，纹理的单个重复单位距离起点偏移多少。
        一般范围是从 *0.0* 到 *1.0*.
        说明: offset属性只是便利修饰符，它只影响纹理应用于模型上的第一组UV值。如果纹理被用作需要额外UV集(比如大大多数储备材料的aoMap或lightMap)的图, 这些UV是必须手动赋值已实现所需要的偏移。
		</p>

		<h3>[property:Vector2 repeat]</h3>
		<p>
		纹理要在表面的UV方向各重复多少次。如果摸个方向上重复值设为比1大的数，那么相应的Wrap参数也应该设为
        [page:Textures THREE.RepeatWrapping] 或[page:Textures THREE.MirroredRepeatWrapping]以达到预期的瓦片效果。
        说明: repeat属性只是一个便利修饰符，它只影响纹理应用于模型上的第一组UV值.  如果纹理被用作需要额外UV集(比如大大多数储备材料的aoMap或lightMap)的图, 这些UV是必须手动赋值已实现所需要的重复。
		</p>

		<h3>[property:number rotation]</h3>
		<p>
        纹理围绕中心点旋转多少，以弧度为单位。正值表示顺时针， 默认值是*0*.
		</p>

		<h3>[property:Vector2 center]</h3>
		<p>
		旋转中心点，(0.5, 0.5)表示纹理的中心，默认值是(0, 0), 也就是纹理的左下角。
		</p>

		<h3>[property:boolean matrixAutoUpdate]</h3>
		<p>
        是否根据纹理的[page:Texture.offset .offset]、[page:Texture.repeat .repeat]、[page:Texture.rotation .rotation]以及[page:Texture.center .center]属性值更新纹理的uv-transform。
        默认是true.如果直接指定uv-transform矩阵，请将此项设为false
		</p>

		<h3>[property:Matrix3 matrix]</h3>
		<p>
		纹理的uv-transform矩阵. 当纹理的[page:Texture.matrixAutoUpdate .matrixAutoUpdate]属性值为true时，渲染器会根据纹理的[page:Texture.offset .offset], [page:Texture.repeat .repeat],
		[page:Texture.rotation .rotation]以及[page:Texture.center .center]属性值更新它。
        如果[page:Texture.matrixAutoUpdate .matrixAutoUpdate]属性值为false, 则必须手动设置矩阵值.
        默认值是单位矩阵
		</p>

		<h3>[property:boolean generateMipmaps]</h3>
		<p>
		是否生成纹理mipmaps (如果可能的话, 默认是true。 如果你要手动创建mipmaps，请将此项设为false
		</p>

		<h3>[property:boolean premultiplyAlpha]</h3>
		<p>
		默认是false, 这是PNG图像的标准。如果存储的RGB已预乘过alpha，则设为false
		</p>

		<h3>[property:boolean flipY]</h3>
		<p>
		默认是True. 翻转图像Y轴以匹配WebGL纹理坐标空间
		</p>

		<h3>[property:number unpackAlignment]</h3>
		<p>
		默认值是4. 指定内存中每个像素行的对其要求。可选的值有1（字节对齐），2（行与偶数字节对齐），4（字对齐）以及8（行从双字边界开始。
		更多信息请参阅[link:http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml glPixelStorei]
		</p>

		<h3>[property:number encoding]</h3>
		<p>
		默认值是[page:Textures THREE.LinearEncoding]
		其它可选值参见[page:Textures texture constants]<br /><br />

		注意，如果在材质已被使用后才改变纹理的encoding值，则需要在着色器中触发Material.needsUpdate 才能使之生效
		</p>

		<h3>[property:Integer version]</h3>
		<p>
		记录[property:Boolean needsUpdate]有多少次被设为 *true*， 从0开始计数
		</p>

		<h3>[property:Function onUpdate]</h3>
		<p>
		回调函数, 纹理更新 (例如, 当needsUpdate值为true且纹理被使用的时候)时被调用.
		</p>

		<h3>[property:Boolean needsUpdate]</h3>
		<p>
        将此设置为* true *以在下次使用纹理时触发更新。 对于设置wrap模式尤其重要
		</p>


		<h2>方法</h2>

		<h3>此类可调[page:EventDispatcher EventDispatcher]方法</h3>

		<h3>[method:null updateMatrix]()</h3>
		<p>
		根据纹理的[page:Texture.offset .offset], [page:Texture.repeat .repeat], [page:Texture.rotation .rotation]以及[page:Texture.center .center]属性更新纹理的uv-transform [page:Texture.matrix .matrix]
		</p>

		<h3>[method:Texture clone]()</h3>
		<p>
		复制纹理，注意不是"深克隆", 图片是共享的.
		</p>

		<h3>[method:Texture toJSON]( [param:Object meta] )</h3>
		<p>
		meta -- 含有元数据的可选对象<br />
		将材质转化为three.js JSON格式
		</p>

		<h3>[method:null dispose]()</h3>
		<p>
		以'dispose'事件类型调用[page:EventDispatcher EventDispatcher].dispatchEvent
		</p>

		<h3>[method:Vector2 transformUv]( [param:Vector2 uv] )</h3>
		<p>
		基于纹理的page:Texture.offset .offset], [page:Texture.repeat .repeat], [page:Texture.wrapS .wrapS], [page:Texture.wrapT .wrapT] 以及 [page:Texture.flipY .flipY]属性值改变纹理的UV值
		</p>

		<h2>源码</h2>

		[link:https://github.com/mrdoob/three.js/blob/master/src/[path].js src/[path].js]
	</body>
</html>
